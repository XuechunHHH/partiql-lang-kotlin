= PartiQL Plan Ion Representation
DRAFT <howero@amazon.com>
:toc:
:toc-title: Page Contents
:sectlinks:

This documents defines a representation of xref:partiql_plan_specification[PartiQL Plans] as an Ion document. For plan semantics and specifcation, see xref:plan_specification[PartiQL Plan Specification]. The plan representation is guided by the following goals:

include::parts.adoc[]

== Goals

.Portable
The plan language should be a valid Ion document for portability across various systems.

.Versioned
A full versioning story is out of scope, but for now we get a `MAJOR.MINOR` string. The `0.x` versions are considered experimental and there are no compatibility guarantees prior to `1.0`.

.Decomposable
A plan should be decomposable and distributed across multiple systems.

.Extensible
We need a mechanism to model custom types, expressions, and operators. These things are out of scope, but a prelude has been carved out.

.Concise
We'll use tagged s-expression with positional parameters to define nodes as it's familiar, expressive, and concise.

[#partiql-plan-structure]
== Plan File Basics

=== Structure

A PartiQL Plan file is a top-level Ion xref:https://amazon-ion.github.io/ion-docs/docs/spec.html#sexp[s-expression] with the following structure:

[source,ion]
----
(
  partiql :: plan                // PartiQL Plan marker

  version :: (0 1)               // PartiQL Plan version

  (include ...)                  // Include prelude

  (env ...)                      // Environment

  (statement ...)                // Statement to execute, `main`
)
----

// Each Ion value (respectively) represents:
//
// * The `partiql::(MAJOR MINOR)` version pair,
// * Included header files containing types, constants, and node definitions
// ** More on this later
// * A container of constant values
// * A container of node type annotations demarcated within an s-expr `(types ...)`
// * A container of labeled nodes demarcated within an s-expr `(define ...)`
// * The _statement_ s-expression
//
// Nodes represent statements, expressions (`rex`), relational operators (`rel`), and types. A node begins with a `snake_case` Ion symbol as the head element followed by parameters. This symbol uniquely identifies which node the s-expression represents and is called a _tag_.
//
// === Example
//
// Here is an example query and plan
//
// .Basic Query
// [source,partiql]
// ----
// SELECT t.a as a, t.b as b FROM T as t WHERE t.c > 0
// ----
//
// .Basic Example Environment
// [source,ion]
// ----
// // Ion Schema
// type::{
//   name: envirnoment,
//   type: struct,
//   fields: {
//     T: type::{
//       name: my_table,
//       type: list,
//       element: type::{
//         type: struct,
//         fields: {
//           a: int,
//           b: int
//         }
//       }
//     }
//   }
// }
//
// // Values
// // {
// //   T: [
// //     { "a": 0, "b": 1 },
// //     { "a": 2, "b": 3 },
// //   ]
// // }
// ----
//
// .Basic Plan Example
// [source,ion]
// ----
// (
//   partiql :: plan
//
//   version :: (0 1)
//
//   (include
//     (partiql '**' '*')   // Include partiql header, read as `import partiql::**::*`
//   )
//
//   type::{
//     name: envirnoment,
//     type: struct,
//     fields: {
//       T: type::{
//         name: my_table,
//         type: list,
//         element: type::{
//           type: struct,
//           fields: {
//             a: int,
//             b: int
//           }
//         }
//       }
//     }
//   }
//
//   // global names to type definitions map
//
//   (env
//     T::(array                                     // "T" is array of tuples with open schema
//       (a ($namespace partiql::0 ($type int::5)))  // known element a, type PartiQL Int
//       (b ($namespace partiql::0 ($type int::5)))  // known element b, type PartiQL Int
//       |
//       t                                           // open element container
//     )
//   )
//
//   (constants
//     (lit ($namespace partiql::0 ($type string::13)) "T")
//   )
//
//   (statement
//     (query
//       (select { a: ($var 0), b: ($var 1) }      // Rex: sfw, construct bag of { a: $0, b: $1 }
//
//         (project (($var 0) ($var 1))            // Rel: relation projection of resolved variables in registers 0 and 1
//
//           (filter (call ())                     // Rel: filter on call `partiql.gt(t.c, 0)`
//
//             (scan ($env 0))                     // Rel: scan resolved global variable "T"
//   )))))
//
//   (query                            // Statement: QUERY
//     (select ('a' 'b')               // Rex:
//       (project ($1 $2)              // Rel: project vars 1, 2 to slots 0, 1 respectively (could be pushed into filter)
//         (filter (call ($namespace 0 ($fn 0))                // Rel: filter on the expression labeled by gt0
//           (scan (global case_sensitive "T"))                // Rel: "T"
//   ))))
// )
// ----

// === Labels and References
//
// For example,
//
// [source,ion]
// ----
// (plan version::'0.0'
//
//   // Label 'gt0' assigned to `$0 > 1` call expression node
//   gt0 :: (call gt $0 (lit (int) 0))
//
//   // Label 'my_table' assigned to Ion string "X"
//   my_table :: "X"
//
//   // SELECT a FROM X WHERE a > 0
//   (query                                          // Statement: QUERY
//     (select                                       // Exp: Relation-Value Projection, No Constructor
//       (project ($0)                               // Rel: PROJECT
//         (filter $gt0                              // Rel: FILTER
//           (scan_collection (global $my_table))    // Rel: SCAN
//   ))))
// )
// ----
//
// NOTE: The labels `$n` for integers n corresponds to the expression node `(var n)` — ie `$1` is equivalent to `(var 1)`
//
// Also note that labeling nodes is different than the optional annotations for positional parameters. Positional parameters have optional annotations simply for readability; those
// annotations are not labels.

[#types]
== TODO Types

The plan `(type ...)` container is where types used within a plan are defined. The plan supports defining atomic, product, and union types footnote:[As presented, you cannot define an atomic type named "union" or "product".]. Here is a basic set of types which defines an integer, float, number union, and number pair.

Additionally, you can define open-schema and closed-schema collections of type:
* array — ordered collection
* bag — unordered collection
* tuple — key-value pairs

.Types Example
[source,ion]
----
(
  partiql::(0 1)

  // Syntax (annotations optional)
  //
  // def ::= ( [product|union] <symbol> <ref>+ )
  // ref ::= <int>

  (types
    (int)                   // atomic type "int"
    (float)                 // atomic type "float"
    (decimal 0 0)           // atomic type "decimal" with two int parameters
    (union number           // union type "number"
      (
       int::0
       float::1
       decimal::2
      )
    )
    (product pair           // product type "pair"
      (number::3 number::3) // operands: type 3 (number), type 3 (number)
    )
    (array closed 3)        // array of numbers
  )
)
----

.Normalized Example
[source,ion]
----
(
  partiql :: (0 1)

  (type)

  (define
    gtints  :: (fn 'gt' (int int) (bool))              // `fn` definition node
    gt0     :: (call (@ 0) (var 0) (lit (int) 0))      // `call` rex node
  )

  // INPUT      | SELECT a, b FROM T as t WHERE c > 0
  // NORMALIZED | SELECT _0.a as a, _0.b as b FROM T as _0 WHERE _0.c > 0

  (query                            // Statement: QUERY
    (select ('a' 'b')               // Rex: sfw, construct bag of { a: $0, b: $1 }
      (project ($1 $2)              // Rel: project vars 1, 2 to slots 0, 1 respectively (could be pushed into filter)
        (filter $gt0                // Rel: filter on the expression labeled by gt0
          (scan 'T' ('a' 'b' 'c')   // Rel: scan 'T', assigning c, a, b to slots 0, 1, 2 respectively
  ))))

)
----

// == Plan Header

// == Plan Part

== Statements

A plan contains a single _statement_. A statement may be a query, or other database operations such as creating views, creating tables, or inserting data as shown in <<partiql-plan-structure,PartiQL Plan Structure>>.

.Statement Node Types
[cols="1,5a",grid=rows,frame=all]
|===
| Variant | Description

| <<query-statement-node,query>>
| Query such as a value expression or SELECT-FROM-WHERE (query) expression

// | insert | DML INSERT
//
// | insert_value | DML INSERT VALUE
//
// | upsert | DML UPSERT
//
// | replace | DML REPLACE
//
// | update | DML UPDATE
//
// | remove | DML REMOVE
//
// | delete | DML DELETE
//
// | create_table | DDL CREATE TABLE
//
// | create_index | DDL CREATE INDEX

| <<create-view-statement-node,create_view>>
| DDL `CREATE VIEW` statement

// | drop_table | DDL DROP TABLE
//
// | drop_index | DLL DROP INDEX

2+a|

NOTE: This document's scope is limited to `query` and `create_view` statements, see <<document-scope>>.

|===

=== `query`

[#query-statement-node]
====

[discrete.text-center]
=== Query Statement Node

[.text-center]
_variant of statement_

'''

This statement represents a simple PartiQL Query.

.Form
[source,ion]
----
(query <rex>)
----

.Parameters
[cols="1m,5",grid=rows,frame=all]
|===
| Type | Description

| rex | The root expression node of a query.

|===

.Example
[source,partiql]
----
SELECT a, b FROM T
----

[source,ion]
----
(query
  (select (...)                         // TODO add schema
    (project ((var 0 any) (var 1 any))
      (scan
        (global collection "T")
      )
    )
  )
)
----

====

=== `create_view`

====
[.text-center]
_variant of statement_

'''

This statement represents `CREATE VIEW` (SQL-Statement 84) in a PartiQL Plan. Its specification in PartiQL is pending an RFC.

.Form
[source,ion]
----
(create_view name::<string> (columns <symbol>*) query::<rex>)
----

.Parameters
[cols="1m,3",grid=rows,frame=all]
|===
| Type | Description

| name::string | The view's name

| (columns string*) | Optional parameter for the view's columns — to be defined for PartiQL

| query::rex | The view's query expression

|===

.Example
[source,ion]
----
CREATE VIEW example AS SELECT * FROM T
----

[source,ion]
----
(create_view "example"
  (select
    (project ((path (star))))
      (scan
        (global "T" collection)
      )
    )
  )
)
----

====

// == DML

// == GPML

// == DCL

// == TCL

== Rex Nodes

Within statements are several expression nodes. The following section defines all _expression_ variants. For more details, see the specification for <<value-rex-summary,PartiQL Value Expressions>>.

.Rex Node Summary
[cols="1,3a",grid=rows,frame=all]
|===
| Variant | Description

|<<literal-rex-node,lit>>
| Literal value expressions

|<<var-rex-node,var>>
| Reference to a binding in the variable tuple environment

|<<global-rex-node,global>>
| Reference to a binding in the global environment

|<<path-rex-node,path>>
| Path expression

|<<call-rex-node,call>>
| Function call

// |<<switch-rex-node,switch>>
// | Switch expression, ex: SQL `CASE`
//
// |<<tuple-rex-node,tuple>>
// | Tuple constructor expressions
//
|<<struct-rex-node,struct>>
| Struct constructor expression
//
// |<<array-rex-node,array>>
// | Array constructor expression
//
|<<pivot-rex-node,pivot>>
| Pivot expression to produce a single tuple from a binding collection

|<<coll-to-scalar-node,coll_to_scalar>>
| Scalar subquery coercion node

|<<select-rex-node,select>>
| SELECT-FROM-WHERE expression

|===

[#literal-rex-node]
=== `lit`

====

[.text-center]
_variant of rex_

'''

Literal expressions are _PartiQL Values_ represented with Ion literals. We necessarily include the PartiQL Type in the node value.

.Form
[source,ion]
----
rex.lit ::= (lit <type> <ion>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| type | PartiQL type

| ion | Ion representation of the PartiQL valuefootnote:[There should be an appendix to explain this]

|===

.Examples
[source,ion]
----
// annotations are simply for readability

(lit ($type bool::0) false)

(lit ($type decimal::3) 1.50)

(lit ($type bag::17) [ "x", "y", "z" ])

(lit ($type array::18) [ 0, 1, 2 ])

(lit ($type struct::19) {
  "x": 0,
  "y": 1,
  "z": 2,
})

(lit ($type string::9) "abc")

(lit ($type missing::1) null)

(lit ($type null::2) null)
----

====

[#global-rex-node]
=== `global`

====

[.text-center]
_variant of rex_

'''

Global references are expressions which reference a global binding. That is, they reference a binding name in the database environment.

.Form
[source,ion]
----
rex.global ::= (global <type> <int>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| <type> | PartiQL Type

| <int> | Global resolved reference ordinal

Default `INSENSITIVE`

|===

.Examples
[source,ion]
----
// TODO
----

====

[#var-rex-node]
=== `var`

====

[.text-center]
_variant of rex_

'''

Recall the global and variable binding environments. Variable references are expressions which reference a binding in the variable binding environment. This means that variable binding expressions are only valid within a query subtree. For example, the query `1 + a` where `a` is a _variable reference_

.Form
[source,ion]
----
rex.var ::= (var <type> <int>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| type | The variable's PartiQL Type.

| int
a| Ordinal in the current variable binding environment

|===

.Example Variable Env
[source,partiql]
----
< 0: 'hello', 1: << 1.0, 1.1 >> >
----

.Example Nodes
[source,ion]
----
(var ($type string::9) 0)   // 'hello'

(var ($type bag::11) 1)     // << 1.0, 1.1 >>
----

====

[#path-rex-node]
=== `path`

====

[.text-center]
_variant of rex_

'''

A path expression is composed of a root and one or more path steps. We represent this in the Ion model as a tagged and type annotated s-exression of the path steps.

.Form
[source,ion]
----
rex.path ::= (path <type> root::<rex> steps::(<step>+))

step ::= <step.key> | <step.wildcard> | <step.unpivot>

step.key ::= (step <rex>)

step.wildcard ::= (step wildcard)

step.unpivot ::= (step unpivot)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| type | Rex type reference

| (step+) | Non-empty list of steps. A step node is either an index, the symbol `wildcard`, or the symbol `unpivot`

|===

.Examples
[source,ion]
----
// Types
(types
  (symbol) // type 0
)

// Let `a` be resolved to (var ($type x) 0).

// `a.b.c`
(path ($type ?)
  (var ($type x) 0) (
    (step (lit ($type 0) b))
    (step (lit ($type 0) c))
))

// `a.b[*]`
(path ($type ?)
  (var ($type x) 0) (
    (step (lit ($type 0) b))
    (step wildcard)
))

// `a.*`
(path ($type ?)
  (var ($type x) 0) (
    (step unpivot)
))
----

====

[#call-rex-node]
=== `call`

====

[.text-center]
_variant of rex_

'''

A call expression represents invocation of the function `fn` with the arguments `args`. The `fn` node is a reference to a function type that is either included or defined in the header.

.Form
[source,ion]
----
fns ::= (fns <fn>*)                 // Function definitions

fn ::= (fn <symbol> <opts> (param*) returns::<type>)

param ::= <param-value | param-type>

param-value ::= (v <type>)

param-type ::= (t <type>)

call ::= (call <fn> (<arg>*))       // Rex call

arg ::= <arg-value> | <arg-type>    // Rex call argument

arg-value ::= (v <rex>)             // Rex call value arg

arg-type  ::= (t <type>)            // Rex call type arg
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| fn | Function signature reference (symbol) or inline definition

| (args rex*) | Tail param is a list of expressions

|===

.Examples
[source,ion]
----
(types
  (int)     // ($type 0)
  (float)   // ($type 1)
)

(fns
  (fn plus ((v ($type 0)) (v ($type 0))) returns::($type 0)) // ($fn 0) <int> + <int>
  (fn plus ((v ($type 1)) (v ($type 1))) returns::($type 1)) // ($fn 1) <float> + <float>
  // casts
  (fn cast ((v ($type 0)) (t ($type 1))) returns::($type 1)) // ($fn 3) CAST(<int> AS <float>)
)
----

NOTE: I have left this out, but we should consider a bit flag for whether or not to add implicit casts as well as null/missing propagation.

[source,ion]
----
// 0x00 -> explicit cast
// 0x01 -> implicit cast
// 0x0_ -> do not propagate null + missing
// 0x1_ -> propagate null + missing

(fn plus 0x11 ...)

// function would resolve with implicit casts
----

====

[#struct-rex-node]
=== `struct`

====

[.text-center]
_variant of rex_

'''

A struct constructor differs from a struct literal because expressions may be used to _construct_ the tuple value.
Struct key expressions must evaluate to a value with a character string type.

.Form
[source,ion]
----
rex.tuple ::= (tuple <type> (<rex> <rex>)*)
----

.Parameters
[cols="1m,2",grid=rows,frame=all]
|===
| Type | Description

| (<rex> <rex>)* | Zero or more key-value expression pairs

|===

.Examples
[source,partiql]
----
{ 'a': 1 }

{ 'b': 2, 'c': x }
----

[source,ion]
----
// TODO
----

====
//
// [#bag-rex-node]
// === `bag`
//
// ====
//
// [.text-center]
// _variant of rex_
//
// '''
//
// A Bag Constructor produces a bag value from a collection of expressions.
//
// .Form
// [source,ion]
// ----
// (bag (type type) | rex*)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | type | Optional bag element type if known
//
// | rex* | Zero or more expression elements
//
// |===
//
// .Examples
// [source,partiql]
// ----
// << { 'a': 1 }, { 'b': 2 } >>
// ----
//
// [source,ion]
// ----
// (bag
//   (tuple (
//     (lit string "a") (lit int 1))
//   )
//   (tuple (
//     (lit string "b") (lit int 2))
//   )
// )
// ----
//
// ====
//
// [#array-rex-node]
// === `array`
//
// ====
//
// [.text-center]
// _variant of rex_
//
// '''
//
// An Array Constructor produces an array value from a collection of expressions.
//
// .Form
// [source,ion]
// ----
// (array (type type) | rex*)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | type | Optional array element type if known
//
// | rex* | Zero or more expression elements
//
// |===
//
// .Examples
// [source,partiql]
// ----
// [ 'a', 'b', 'c' ]
// ----
//
// [source,ion]
// ----
// (array
//   (lit string "a")
//   (lit string "b")
//   (lit string "c")
// )
// ----
//
// ====
//
//
[#pivot-rex-node]
=== `pivot`

====

[.text-center]
_variant of rex_

'''

The pivot expression produces a single tuple from a query. Each key-value pair in the output tuple is produced by evaluating the given key and value expressions from its relational operator.

.Form
[source,ion]
----
rex.pivot ::= (pivot <type> key::<rex> val::<rex> <rel>)
----

.Parameters
[cols="1m,2",grid=rows,frame=all]
|===
| Type | Description

| type | The pivot expressions output type

| key::rex | Pivot key expression

| val::rex | Pivot value expression

| rel | Relational operator node which represents the PIVOT-FROM-WHERE.

|===

.Example
[source,partiql]
----
PIVOT v AT k FROM ...

(pivot (var ($type i) k::0) (var ($type j) v::1)
  (scan ...)
)
----

====

[#coll-to-scalar-rex-node]
=== `coll_to_scalar`

====

[.text-center]
_variant of rex_

'''

The `coll_to_scalar` expression represents PartiQL's scalar subquery coercion function described here https://partiql.org/dql/subqueries.html.

.Form
[source,ion]
----
(coll_to_scalar <rex.select>)
----

.Parameters
[cols="1m,2",grid=rows,frame=all]
|===
| Type | Description
| rex.select | Query expression to coerce.

|===

.Examples
[source,ion]
----
// todo
----

====

[#select-rex-node]
=== `select`

====

[.text-center]
_variant of rex_

'''

The `select expression represents a SELECT-FROM-WHERE query expression. See https://partiql.org/dql/overview.html#_select_value for details.
The constructor defines the value-relation projection.

.Form
[source,ion]
----
(select <rex> <rel>)
----

.Parameters
[cols="1m,2",grid=rows,frame=all]
|===
| Type | Description
| rex | Constructor expression
| rel | Relational operator node

|===

.Examples
[source,ion]
----
// todo
----

====

== Rel Nodes

Rel nodes represent the relational expressions from the PartiQL Plan Specification.

.Rel Nodes Summary
[cols="1,5a",grid=rows,frame=all]
|===
| Variant | Description

| <<scan-rel-node,scan>>
| Produce a collection of bindings from a value expression

| <<scan-indexed-rel-node,scan_indexed>>
| Produce a collection of bindings from a value expression, with index

| <<unpivot-rel-node,unpivot>>
| Produce a collection of bindings from key-value pairs of tuples

| <<project-rel-node,project>>
| Apply the projection expressions to the input binding tuples

// | <<cross-rel-node,cross>>
// | Produce the cross product of two relation expressions
//
// | <<filter-rel-node,filter>>
// | Filters the input relation on a given predicate expression
//
// | <<sort-rel-node,sort>>
// | Sorts the given relation
//
// | <<aggregate-rel-node,aggregate>>
// | Applies the aggregate calls to the given relation
//
// | <<set-rel-nodes,union>>
// | Union of two relations
//
// | <<set-rel-nodes,intersect>>
// | Intersection of two relations
//
// | <<set-rel-nodes,except>>
// | Multiset difference
//
// | <<fetch-rel-nodes,limit>>
// | LIMIT
//
// | <<fetch-rel-nodes,offset>>
// | OFFSET
//
// | <<fetch-rel-nodes,fetch>>
// | LIMIT ... OFFSET
//
// | <<join-rel-node,join>>
// | Relation join
//
// | <<user-defined-rel-node,op>>
// | User-defined relation operator

|===

Each `rel` node has a `schema` node as its first element. The `schema` node is an sexp of type references
which describe each output tuple's schema.

[source,ion]
----
schema ::= (<type>+)
----

[#scan-rel-node]
=== `scan`

====

[.text-center]
_variant of rel_

'''

.Form
[source,ion]
----
rel.scan ::= (scan <schema> <rex>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| schema | Output schema of this operator.

| rex | Expression to scan.

|===


.Examples
[source,ion]
----
// TODO
----

====
// END scan-rel-node

// BEGIN scan-indexed-rel-node
[#scan-indexed-rel-node]
=== `scan_indexed`

====

[.text-center]
_variant of rel_

'''

The `scan_indexed` node is much like the `scan` node, but its output tuples contain an additional index field.

.Form
[source,ion]
----
rel.scan_indexed ::= (scan_indexed <schema> <rex>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| schema | Output schema of this operator.

| rex | Expression to scan.

|===


.Examples
[source,ion]
----
// TODO
----

====
// END scan-indexed-rel-node

// BEGIN unpivot-rel-node
[#unpivot-rel-node]
=== `unpivot`

====

[.text-center]
_variant of rel_

'''

.Form
[source,ion]
----
(unpivot <schema> <rex>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| schema | Output key-value types — (($type k) ($type v))

| rex | Collection to unpivot

|===

If an `(at expression)` is specified, then the output binding 0 takes on the value of that expression, and binding 1 is the corresponding

.Unpivot Example
[source,partiql,subs=quotes]
----
FROM UNPIVOT { k~0~: v~0~ , ... , k~n~: v~n~ } AS v AT k

-- Result
<<
  { k: k~0~, v: v~0~ },
  ...
  { k: k~n~, v: v~n~ }
>>
----

.Examples
[source,ion,subs=normal]
----
(unpivot (at (var 0 string))
  (lit tuple { k~0~: v~0~, ... , k~n~: v~n~ })
)

// <<
//    < 0: k~0~, 1: v~0~ >,
//     ...
//    < 0: k~n~, 1: v~n~ >
// >>
----
====
// END unpivot-rel-node

[#project-rel-node]
=== `project`

====

[.text-center]
_variant of rel_

'''

The `project` node represents a relation-to-relation projection function.

.Form
[source,ion]
----
(project (<rex*>) <rel>)
----

.Parameters
[cols="1m,4",grid=rows,frame=all]
|===
| Type | Description

| (rex*) | Expression list of projections

| op::operator | Input relation operator

|===

.Examples
[source,ion]
----
// TODO example out-of-date

(project ( (var 1) )
  (scan (lit bag [
    { "a": 10, "b": 20 },
    { "a": 30, "b": 40 },
  ]))
)
// <<
//   < 0: 20 >,
//   < 0: 40 >,
// >>
----

====


// [#filter-rel-node]
// === `filter`
//
// ====
//
// [.text-center]
// _variant of rel_
//
// '''
//
// .Form
// [source,ion]
// ----
// (filter condition::expr | op::operator)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | condition::rex | Filter condition
//
// | op::operator | Input relation operator
//
// |===
//
// .Examples
// [source,ion]
// ----
// (filter (call gte (args (var 0) (var 1)))
//   (scan (lit bag [
//     { "x": 0, "y": 1 },
//     { "x": 1, "y": 1 },
//     { "x": 2, "y": 1 },
//   ]))
// )
// // <<
// //   < 0: 2, 1: 1 >,
// //   < 0: 2, 1: 1 >
// // >>
// ----
// ====
//
// [#cross-rel-node]
// === `cross`
//
// ====
//
// [.text-center]
// _variant of rel_
//
// '''
//
// The cross product operation combines every tuple from the left input with every tuple of the right input. See <<multi-item-from,multi-item from>>.
//
// .Form
// [source,ion]
// ----
// (cross | lhs::operator rhs::operator)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | lhs::operator | Left input relation operator
// | rhs::operator | Right input relation operator
//
// |===
//
// ====
//
// [#sort-rel-node]
// === `sort`
//
// ====
//
// [.text-center]
// _variant of rel_
//
// '''
//
// .Form
// [source,ion]
// ----
// (sort (sort_spec+) | op::operator)
//
// // sort_spec
// (expr::rex (dir symbol) (nulls symbol))
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | sort_spec | An s-expression containing an expression to sort on, optional sort direction, and optional null ordering.
//
// |===
//
// .Examples
// [source,ion]
// ----
// (sort (
//    ((var 0) (dir ASC) (null DESC))
//   )
//   (scan (lit bag [
//     { "a": 10, "b": 20 },
//     { "a": 30, "b": 40 },
//   ]))
// )
// ----
//
// ====
//
// [#aggregate-rel-node]
// === `aggregate`
//
// ====
//
// [.text-center]
// _variant of rel_
//
// '''
//
// .Form
// [source,ion]
// ----
// (aggregate calls::(agg*) groups::(rex*) | op::operator)
//
// (agg fn | (args rex*))
//
// (fn (symbol+) (type*) type) // same `fn` as a call
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | agg | An s-expression defining the aggregation function to invoke
//
// | groups::(rex*) | A list of aggregate grouping expressions
//
// | op::operator | Input relation expression to aggregate
//
// |===
//
// .Examples
// [source,ion]
// ----
// -- SELECT SUM(a) FROM table GROUP BY b
//
// (aggregate
//   (
//     (agg sum (args (var 0 int)))
//   )
//   (
//     (var 1 string)
//   )
//   (scan (lit bag [
//     { "a": 1, "b": "x" },
//     { "a": 2, "b": "x" },
//     { "a": 3, "b": "y" },
//     { "a": 4, "b": "y" },
//   ]))
// )
// ----
// ====
//
// [#set-rel-nodes]
// ====
// [discrete.text-center]
// === Set Operator Nodes
//
// [.text-center]
// _variants of operator_
//
// '''
//
// .Form
// [source,ion]
// ----
// (union (all bool) | lhs::operator rhs::operator)
//
// (intersect (all bool) | lhs::operator rhs::operator)
//
// (except (all bool) | lhs::operator rhs::operator)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | (all bool) | If specified, then use the multiset (bag) operator.
//
// |===
//
// Let _rel~L~_ and _rel~R~_ be two relation operator nodes.
//
// .Examples
// [source,ion,subs=normal]
// ----
// (union rel~L~ rel~R~)           // UNION DISTINCT
//
// (intersect  rel~L~ rel~R~)      // INTERSECT DISTINCT
//
// (except rel~L~ rel~R~)          // EXCEPT DISTINCT
//
// (union (all) rel~L~ rel~R~)     // UNION ALL
//
// (intersect (all) rel~L~ rel~R~) // INTERSECT ALL
//
// (except (all) rel~L~ rel~R~)    // EXCEPT ALL
// ----
//
// ====
//
// [#fetch-rel-nodes]
// === `fetch`
//
// ====
//
// [.text-center]
// _variant of rel_
//
// '''
//
// .Form
// [source,ion]
// ----
// (limit n:int | op::operator)
//
// (offset n:int | op::operator)
//
// (fetch (limit int) (offset int) | op:operator)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// |===
//
// Let _variant of rel_ be some relation operator node.
//
// .Examples
// [source,ion]
// ----
// (limit 10 rel)
//
// (offset 1 rel) // skip first binding tuple
//
// (fetch (limit 10) (offset 1) rel) // equivalent to (limit 10 (offset 1 rel))
// ----
//
// ====
//
// [#join-rel-node]
// === `join`
//
// ====
//
// [.text-center]
// _variant of rel_
//
// '''
//
// .Form
// [source,ion]
// ----
// (join type::symbol (on expression) | lhs::operator rhs::operator)
// ----
//
// .Parameters
// [cols="1m,4",grid=rows,frame=all]
// |===
// | Type | Description
//
// | type::symbol | Join type, one of `INNER`, `LEFT`, `RIGHT`, `FULL`
//
// | (on expression) | Optional join condition expression
//
// | lhs::operator | Left side relation node
//
// | rhs::operator | Right side relation node
//
// |===
//
// Let _rel~L~_ and _rel~R~_ be two relation operator nodes.
//
// .Examples
// [source,ion,subs=normal]
// ----
// (join INNER
//   rel~L~
//   rel~R~
// )
//
// (join INNER
//   (on (call eq (args (var 0 int8) (var 2 int8))))
//   rel~L~  // < 0: .., 1: .. >
//   rel~R~  // < 0: .., 1: .. >
// )
// ----
// ====


// [#user-defined-rel-node]
// === `u`
// [discrete.text-center]
// === User-Defined Operator Node

// [.text-center]
// _variant of rel_

// '''

// This operator is similar to the value expression <<call-rex-node,call>> node, but the provided function returns a collection of binding tuples rather than a PartiQL value. It's argument list can be comprised of both value expressions and relation expressions.

// .Form
// [source,ion]
// ----
// (op
//   (symbol+)
//   (args (expression|operator)*)
// )
// ----

// .Parameters
// [cols="1m,1",grid=rows,frame=all]
// |===
// | Type | Description

// | symbol+ | One or more function identifier symbols

// | (args (expression\|operator)*)
// | Zero or more function arguments

// |===

// .Examples
// [source,ion,subs=normal]
// ----
// (op (redis get) (args (lit string "my-key")))
// ----

// ====


== Appendices

[#metasyntax]
=== I — Plan Node Metasyntax

==== Node Forms

Throughout this section we'll use a metasyntax to describe valid forms of s-expressions nodes. It is important to remember we are using this metasyntax to describe Ion values, not PartiQL values. We call the metasyntax for a node it's _form_, and it has the general structure:

.Node Form
[source,subs="normal"]
----
(symbol name~p~::type~p~* (name~n~ type~n~)* | name~t~::type~t~*)

        └─────┬─────┘└─────┬──────┘   └─────┬─────┘
          positional     named             tail

* indicates 0 or more
+ indicates 1 or more
? indicates 0 or 1
----

[admonition,caption="TYPES"]
====
When we define the _type_ for parameters of a node, we are describing the Ion value's type. Which means valid type values are symbols for the xref:https://amazon-ion.github.io/ion-docs/docs/spec.html#the-ion-data-model[Ion types] *or* a plan node tag. Additionally, we will define xref:https://en.wikipedia.org/wiki/Tagged_union[union types] for node types which have several variants — for example, the node type `exp` represents any of the expression nodes.

The symbol `any` in the metasyntax is used to denote any Ion type — not to be confused with a reference to the PartiQL _<<any-type,any>>_ type.
====

A node begins with a snake_case Ion symbol as the head element followed by parameters. This symbol uniquely identifies which plan node the s-expression represents and is called a _tag_. After the tag there are three groups of parameters: positional, named, and tail parameters. See <<parameter-motivation, motivation for parameter types>>.

==== Positional Parameters

Positional parameters take the form `name~p~::type~p~` and are both *required* and *non-variadic*. When defining a node, we give an optional name annotation `name~p~` and the parameter type `type~p~`.

For example, the form `(foo a::int b::int)` defines a node `foo` with two positional arguments of type Ion int. Positional argument name annotations are optional, so all three examples are equivalent,

.Example Values
[source,ion]
----
(foo 1 2)
(foo a::1 2)
(foo a::1 b::2)
----

==== Named Parameters

Named parameters follow positional parameters and take the form `(name~n~ type~n~)` — they are *optional* and *non-variadic*. The order of named parameters does not matter, only that they appear after all positional arguments and before any tail parameters.

For example, the form `(bar x::int (y int) (z int))` defines a node `bar` with one positional argument and two named arguments. The following values are all valid `bar` nodes.

.Example Values
[source,ion]
----
(bar 1)
(bar 1 (y 2))
(bar 1 (z 3))
(bar 1 (y 2) (z 3))
(bar 1 (z 3) (y 2))
----

==== Tail Parameters

The symbol `|` in the metasyntax is an indicator that all following parameters are tail parameters. This symbol does _not_ appear in values and is simply an indicator in the metasyntax. Tail parameters are *required* and *the final parameter may be variadic* (denoted using the `*`, `?`, and `+` operators).

For example, the form `(box width::int height::int (color int) | child::element?)` defines a node `box` with required width and height, optional named parameter color, and an optional child of type element. Let `(p text::string)` be a variant of the element type, then some valid box node values are:

.Example Values
[source,ion]
----
(box 256 256
  (p "Hello")
)

(box width::256 height::256 (color 0x00_FF_00))

(box 960 720 (color 0x00_00_FF)
  (p "Your PC ran into a problem")
)
----

[example,#parameter-motivation]
====

[discrete]
==== Parameter Motivation

How do we represent required, optional, and variadic elements while maintaining tree aesthetics? We don't want plan representations to be debug dumps, rather we want them to be concise with elegance.

A common technique for nicely formatted trees is placing children last. In doing so, a node's non-child parameters are grouped with its identifier and the tree continues downwardfootnote:[Upward if you're in Australia].

To achieve aesthetic goals, we split parameters into three categories: positional, named, and tail parameters.
====

=== II — Graphs in Ion Brainstorming

Describing nodes with the s-expressions is fine, but the optional and tail parameters can be odd.

I'm also going to present two syntaxes. One is a PartiQL Plan DSL that's a variation of DOT. The other is an attempt to recreate this as valid Ion.

Also, no ambiguity ie no optional values ??

.Defining Nodes
[source,subs="normal"]
----
(symbol name~p~::type~p~* (name~n~ type~n~)* | name~t~::type~t~*)

        └─────┬─────┘└─────┬──────┘   └─────┬─────┘
          positional     named             tail

* indicates 0 or more
+ indicates 1 or more
? indicates 0 or 1
----


.Requirements
* Define a node
* Node property inheritance / definitions? aka node taxonomy
* Assign labels
* Assign label to an inline definition
* Designate a statment
** A statement is specified with the `statement` keyword followed by the statement type.

[source,plan]
----
-- CREATE TABLE test (
--  id INT
-- );
-- INSERT INTO test (id) VALUES (1);
-- INSERT INTO test (id) VALUES (2);
-- SELECT t.id FROM test AS t WHERE t.id > 0;
-- SELECT t.id FROM test AS t WHERE t.id > 1;

my_table := 'test'
my_pk := 'id'

(create_table my_table (
  (my_pk int)
))

(insert my_table (lit (int) 1))
(insert my_table (lit (int) 2))

(scan my_table) # my_scan
(project $0)    # my_project

(filter (call gt $0 (lit (int) 0))) # gt0 -- $0 > 0
(filter (call gt $0 (lit (int) 1))) # gt1 -- $0 > 0

(query
  (select
    (flow
      my_scan -> gt0 -> my_project
    )
  )
)

(query
  (select
    (flow
      #gt0 -> #my_project # in
      #my-scan -> #in
    )
  )
)

statement dql.query {
  this_filter := (filter (call gt $0 (lit (int) 0))) -- $0 > 0
  expr = my_scan -> this_filter -> project
}

statement dql.query {
  this_filter := (filter (call gt $0 (lit (int) 1))) -- $0 > 1
  expr = my_scan -> this_filter -> project
}
----

==== PartiQL Plan Language as Ion (?? .ion)

NOTE: The labels `$n` for integers n corresponds to the expression node `(var n)` — ie `$1` is equivalent to `(var 1)`

[source,ion]
----

// Recreating these statements
// ----------------------------
// CREATE TABLE test (
//  id INT
// );
// INSERT INTO test (id) VALUES (1);
// INSERT INTO test (id) VALUES (2);
// SELECT t.id FROM test AS t WHERE t.id > 0;
// SELECT t.id FROM test AS t WHERE t.id > 1;


my_table::'test'                      // assign label 'my_table' to Ion string literal 'test'
my_pk::'id'                           // ...

// CREATE TABLE test (id INT);
(create_table $my_table (
  ($my_pk int)
))

// INSERT INTO test (id) VALUES (1);
(insert $my_table (lit (int) 1))

// INSERT INTO test (id) VALUES (2);
(insert $my_table (lit (int) 2))

gt0::(call gt $0 (lit (int) 0))       // assign label 'gt0' to ($0 > 1) call expression node
gt1::(call gt $0 (lit (int) 1))       // ...

my_scan::(scan $my_table)             // assign label 'my_scan'
my_project::(project ($0))            // ...

// SELECT t.id FROM test AS t
// WHERE t.id > 0;
(query
  (select
    (flow
      ($my_scan '->' (filter $gt0) '->' $my_project)
    )
  )
)

// SELECT t.id FROM test AS t
// WHERE t.id > 1;
(query
  (select
    ($my_project
      (filter $gt1 $my_scan)
    )
  )
)
----

== Appendices

=== I — PartiQL Header

.PartiQL Header
[source,ion]
----
(
  partiql :: header                       // DOCUMENT TYPE

  version :: (0 1)                        // MAJOR MINOR

  namespace :: partiql                    // NAMESPACE

  (types
    (bool)

    (int8)                                // Signed integer that can be stored in one byte
    (int16)                               // Signed integer that can be stored in two bytes
    (int32)                               // Signed integer that can be stored in four bytes
    (int64)                               // Signed integer that can be stored in eight bytes
    (int)                                 // Signed integer of arbitrary size

    (decimal)                             // Exact numeric type with arbitrary precision
    (decimal                              // Exact numeric with specified precision and scale
      precision :: ($type int::3)
      scale     :: ($type int::3)
    )

    (decimal ($type 3) ($type 3))

    (float32)                             // Single-precision floating point (IEEE 754 32-bit)
    (float64)                             // Double-precision floating point (IEEE 754 64-bit)

    (char)                                // Unicode codepoint sequence of fixed length 1
    (char                                 // Unicode codepoint sequence of fixed length n
      length :: ($type int::3)
    )
    (string)                              // Unicode codepoint sequence of variable length
    (string                               // Unicode codepoint sequence of variable length up to n
      extent :: ($type int::3)
    )

    (bit)                                 // Bit string of fixed length 1
    (bit                                  // Bit string of fixed length n
      length :: ($type int::3)
    )
    (binary)                              // Bit string of variable length
    (binary                               // Bit string of variable length up to n
      extent :: ($type int::3)
    )

    (byte)                                // Octet string of fixed length 1
    (byte                                 // Octet string of fixed length n
      length :: ($type int::3)
    )
    (blob)                                // Octet string of variable length
    (blob                                 // Octet string of variable length up to n
      extent :: ($type int::3)
    )

    (date)                                // A date with no time
    (time                                 // A date-less time with seconds precision p and no time zone
      precision :: ($type int::3)
    )
    (time
      precision :: ($type int::3)
      timezone  :: ($type ??)
    )
    (timestamp $_0)                       // A date and time with seconds precision p and no time zone
    (timestamp $_0 $_1)                   // A date and time with seconds precision p and time zone z
    (interval)                            //

    (bag)
    (array)
    (tuple)
    (null)
    (missing)

    (union any *) // special "all" types in this (types ...) block
    (union numeric int8::1 int16::2 int::3 decimal::4 float32::5 float64::6)
    (union text char::7 char_n::9 string::8 string_)
  )

  (constants

    pi :: 3.14159265 // ($constant 0)
  )

  (define


  )

  (select ($constant 0))
)
----

